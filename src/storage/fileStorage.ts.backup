/**
 * File-based Storage System for Kanri Boards
 * 
 * This module implements persistent storage using workspace files,
 * ensuring kanban data travels with the project and persists
 * reliably across VS Code sessions and installations.
 * 
 * Microsoft VS Code Best Practices Implemented:
 * - Uses workspace.fs API for cross-platform file operations
 * - Implements proper error handling with graceful degradation
 * - Creates .kanri directory in workspace root for organization
 * - Uses JSON format for human-readable, version-controllable data
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { KanbanBoard, KanbanCard } from '../config/defaults';
import { Logger } from '../utils/logger';

/**
 * File-based storage manager for Kanri boards
 * 
 * Saves board data as JSON files in the workspace's .kanri directory,
 * making data portable and version-controllable with the project.
 */
export class FileStorage {
    private readonly logger: Logger;
    private readonly storageDir = '.kanri';
    
    constructor(logger: Logger) {
        this.logger = logger;
    }

    /**
     * Get the workspace root directory
     * Required for determining where to store .kanri files
     */
    private getWorkspaceRoot(): vscode.Uri | null {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            this.logger.error('No workspace folder open - cannot save board data');
            return null;
        }
        return workspaceFolders[0].uri;
    }

    /**
     * Ensure the .kanri directory exists in the workspace
     * Creates the directory structure needed for board storage
     */
    private async ensureStorageDirectory(): Promise<vscode.Uri | null> {
        const workspaceRoot = this.getWorkspaceRoot();
        if (!workspaceRoot) return null;

        const kanriDir = vscode.Uri.joinPath(workspaceRoot, this.storageDir);
        
        try {
            // Check if directory exists
            await vscode.workspace.fs.stat(kanriDir);
            this.logger.debug(`Storage directory exists: ${kanriDir.fsPath}`);
        } catch (error) {
            // Directory doesn't exist, create it
            try {
                await vscode.workspace.fs.createDirectory(kanriDir);
                this.logger.info(`Created storage directory: ${kanriDir.fsPath}`);
                
                // Create README file to explain the directory
                await this.createStorageReadme(kanriDir);
            } catch (createError) {
                this.logger.error('Failed to create storage directory', createError);
                return null;
            }
        }
        
        return kanriDir;
    }

    /**
     * Create a README file in the .kanri directory to explain its purpose
     */
    private async createStorageReadme(kanriDir: vscode.Uri): Promise<void> {
        const readmePath = vscode.Uri.joinPath(kanriDir, 'README.md');
        const readmeContent = `# Kanri Board Data

This directory contains your Kanban board data for this project.

## What's stored here:
- Each \`.json\` file represents a Kanban board
- Board data includes columns, cards, and their current state
- Files are automatically created and updated by the Kanri VS Code extension

## Version Control:
- **Commit these files** to track your project's progress over time
- Share board state with your team by committing to your repository
- Board history becomes part of your project history

## File Format:
- Human-readable JSON format
- Can be manually edited if needed (with caution)
- Automatic backups created when boards are deleted

Generated by Kanri for VS Code
`;
        
        try {
            const uint8Array = Buffer.from(readmeContent, 'utf8');
            await vscode.workspace.fs.writeFile(readmePath, uint8Array);
            this.logger.debug(`Created storage README: ${readmePath.fsPath}`);
        } catch (error) {
            this.logger.warn(`Failed to create storage README: ${error}`);
        }
    }

    /**
     * Save a board to a JSON file in the workspace
     * 
     * File structure: .kanri/[boardId].json
     * This makes boards project-specific and version-controllable
     */
    async saveBoard(board: KanbanBoard): Promise<{ success: boolean; error?: string }> {
        try {
            const storageDir = await this.ensureStorageDirectory();
            if (!storageDir) {
                return { success: false, error: 'No workspace available for saving' };
            }

            const fileName = `${this.sanitizeFileName(board.id)}.kanri.json`;
            const filePath = vscode.Uri.joinPath(storageDir, fileName);
            
            // Add metadata for better file management
            const boardData = {
                ...board,
                lastSaved: new Date().toISOString(),
                version: '1.0.0',
                savedBy: 'Kanri for VS Code'
            };

            const jsonData = JSON.stringify(boardData, null, 2);
            const uint8Array = Buffer.from(jsonData, 'utf8');
            
            await vscode.workspace.fs.writeFile(filePath, uint8Array);
            
            this.logger.info(`Board saved successfully: ${filePath.fsPath}`);
            return { success: true };
            
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Failed to save board ${board.id}:`, errorMessage);
            return { success: false, error: errorMessage };
        }
    }

    /**
     * Load a board from its JSON file
     * Returns null if file doesn't exist or can't be read
     */
    async loadBoard(boardId: string): Promise<KanbanBoard | null> {
        try {
            const storageDir = await this.ensureStorageDirectory();
            if (!storageDir) return null;

            const fileName = `${this.sanitizeFileName(boardId)}.kanri.json`;
            const filePath = vscode.Uri.joinPath(storageDir, fileName);
            
            const uint8Array = await vscode.workspace.fs.readFile(filePath);
            const jsonData = Buffer.from(uint8Array).toString('utf8');
            const boardData = JSON.parse(jsonData);
            
            // Validate board structure
            if (!this.isValidBoard(boardData)) {
                this.logger.error(`Invalid board structure in file: ${filePath.fsPath}`);
                return null;
            }
            
            this.logger.debug(`Board loaded successfully: ${filePath.fsPath}`);
            return boardData as KanbanBoard;
            
        } catch (error) {
            if (error instanceof vscode.FileSystemError && error.code === 'FileNotFound') {
                this.logger.debug(`Board file not found: ${boardId}`);
            } else {
                this.logger.error(`Failed to load board ${boardId}:`, error);
            }
            return null;
        }
    }

    /**
     * List all available boards in the workspace
     * Scans .kanri directory for JSON files
     */
    async listBoards(): Promise<KanbanBoard[]> {
        try {
            const storageDir = await this.ensureStorageDirectory();
            if (!storageDir) return [];

            const entries = await vscode.workspace.fs.readDirectory(storageDir);
            const boardFiles = entries
                .filter(([name, type]) => type === vscode.FileType.File && name.endsWith('.kanri.json'))
                .map(([name]) => name.replace('.kanri.json', ''));
            
            const boards: KanbanBoard[] = [];
            for (const boardId of boardFiles) {
                const board = await this.loadBoard(boardId);
                if (board) {
                    boards.push(board);
                }
            }
            
            this.logger.debug(`Found ${boards.length} boards in workspace`);
            return boards.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
            
        } catch (error) {
            this.logger.error('Failed to list boards:', error);
            return [];
        }
    }

    /**
     * Delete a board file from the workspace
     * Creates backup before deletion for safety
     */
    async deleteBoard(boardId: string): Promise<{ success: boolean; error?: string }> {
        try {
            const storageDir = await this.ensureStorageDirectory();
            if (!storageDir) {
                return { success: false, error: 'No workspace available' };
            }

            const fileName = `${this.sanitizeFileName(boardId)}.kanri.json`;
            const filePath = vscode.Uri.joinPath(storageDir, fileName);
            
            // Create backup before deletion
            const backupFileName = `${fileName}.backup.${Date.now()}`;
            const backupPath = vscode.Uri.joinPath(storageDir, backupFileName);
            
            try {
                const fileData = await vscode.workspace.fs.readFile(filePath);
                await vscode.workspace.fs.writeFile(backupPath, fileData);
                this.logger.info(`Backup created: ${backupPath.fsPath}`);
            } catch (backupError) {
                this.logger.warn(`Failed to create backup, proceeding with deletion: ${backupError}`);
            }
            
            await vscode.workspace.fs.delete(filePath);
            this.logger.info(`Board deleted: ${filePath.fsPath}`);
            
            return { success: true };
            
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Failed to delete board ${boardId}:`, errorMessage);
            return { success: false, error: errorMessage };
        }
    }

    /**
     * Get storage statistics for the workspace
     */
    async getStorageStats(): Promise<{ totalBoards: number; totalSize: number; lastModified: Date | null }> {
        try {
            const boards = await this.listBoards();
            let totalSize = 0;
            let lastModified: Date | null = null;

            const storageDir = await this.ensureStorageDirectory();
            if (storageDir) {
                const entries = await vscode.workspace.fs.readDirectory(storageDir);
                for (const [name, type] of entries) {
                    if (type === vscode.FileType.File && name.endsWith('.kanri.json')) {
                        const filePath = vscode.Uri.joinPath(storageDir, name);
                        const stat = await vscode.workspace.fs.stat(filePath);
                        totalSize += stat.size;
                        
                        const fileModified = new Date(stat.mtime);
                        if (!lastModified || fileModified > lastModified) {
                            lastModified = fileModified;
                        }
                    }
                }
            }

            return {
                totalBoards: boards.length,
                totalSize,
                lastModified
            };
        } catch (error) {
            this.logger.error('Failed to get storage stats:', error);
            return { totalBoards: 0, totalSize: 0, lastModified: null };
        }
    }

    /**
     * Sanitize board ID for use as filename
     * Removes/replaces characters that aren't filesystem-safe
     */
    private sanitizeFileName(boardId: string): string {
        return boardId
            .replace(/[^a-zA-Z0-9_-]/g, '_')
            .toLowerCase()
            .substring(0, 50); // Limit length for filesystem compatibility
    }

    /**
     * Validate that loaded data has proper board structure
     * Prevents corruption from malformed JSON files
     */
    private isValidBoard(data: any): boolean {
        return (
            data &&
            typeof data.id === 'string' &&
            typeof data.name === 'string' &&
            Array.isArray(data.columns) &&
            data.columns.every((col: any) => 
                col &&
                typeof col.id === 'string' &&
                typeof col.name === 'string' &&
                Array.isArray(col.cards)
            )
        );
    }
}

/**
 * Factory function to create FileStorage instance
 * Enables dependency injection for testing and modularity
 */
export function createFileStorage(logger: Logger): FileStorage {
    return new FileStorage(logger);
}
